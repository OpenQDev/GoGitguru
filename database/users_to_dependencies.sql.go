// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users_to_dependencies.sql

package database

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const batchInsertUserDependencies = `-- name: BatchInsertUserDependencies :exec
INSERT INTO user_to_dependencies (user_id, dependency_id, first_use_data, last_use_data) VALUES (  
  $1,  
  unnest($2::int[]),  
  unnest($3::bigint[]),  
  unnest($4::bigint[]) 
)
ON CONFLICT (user_id, dependency_id) DO UPDATE 
SET last_use_data = excluded.last_use_data, 
first_use_data = excluded.first_use_data
`

type BatchInsertUserDependenciesParams struct {
	UserID  int32   `json:"user_id"`
	Column2 []int32 `json:"column_2"`
	Column3 []int64 `json:"column_3"`
	Column4 []int64 `json:"column_4"`
}

func (q *Queries) BatchInsertUserDependencies(ctx context.Context, arg BatchInsertUserDependenciesParams) error {
	_, err := q.exec(ctx, q.batchInsertUserDependenciesStmt, batchInsertUserDependencies,
		arg.UserID,
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
	)
	return err
}

const bulkInsertUserDependencies = `-- name: BulkInsertUserDependencies :many
INSERT INTO user_to_dependencies (user_id, dependency_id, first_use_data, last_use_data, updated_at) VALUES (  
  unnest($1::int[]),  
  unnest($2::int[]),  
  unnest($3::bigint[]),  
  unnest($4::bigint[]),
  $5
)
ON CONFLICT (user_id, dependency_id) DO UPDATE
SET last_use_data = excluded.last_use_data,
first_use_data = excluded.first_use_data,
updated_at = excluded.updated_at
RETURNING user_id, dependency_id, updated_at
`

type BulkInsertUserDependenciesParams struct {
	Column1   []int32       `json:"column_1"`
	Column2   []int32       `json:"column_2"`
	Column3   []int64       `json:"column_3"`
	Column4   []int64       `json:"column_4"`
	UpdatedAt sql.NullInt64 `json:"updated_at"`
}

type BulkInsertUserDependenciesRow struct {
	UserID       int32         `json:"user_id"`
	DependencyID int32         `json:"dependency_id"`
	UpdatedAt    sql.NullInt64 `json:"updated_at"`
}

func (q *Queries) BulkInsertUserDependencies(ctx context.Context, arg BulkInsertUserDependenciesParams) ([]BulkInsertUserDependenciesRow, error) {
	rows, err := q.query(ctx, q.bulkInsertUserDependenciesStmt, bulkInsertUserDependencies,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
		arg.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkInsertUserDependenciesRow
	for rows.Next() {
		var i BulkInsertUserDependenciesRow
		if err := rows.Scan(&i.UserID, &i.DependencyID, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDependenciesByUpdatedAt = `-- name: GetUserDependenciesByUpdatedAt :many

WITH computed_dates AS (
    SELECT
        gu.login,
        du.user_id,
        du.dependency_id,
        CASE
            WHEN subquery.last_use_date = 0 THEN NULL
            ELSE LEAST(subquery.last_commit_date, subquery.last_use_date)
        END AS last_use_date,
        CASE
            WHEN subquery.first_use_date = 0 THEN NULL
            ELSE GREATEST(subquery.first_commit_date, subquery.first_use_date)
        END AS first_use_date
    FROM
        user_to_dependencies du
    LEFT JOIN
        dependencies d ON du.dependency_id = d.internal_id
    LEFT JOIN
        github_users gu ON du.user_id = gu.internal_id
    LEFT JOIN
        github_user_rest_id_author_emails gure ON gu.github_rest_id = gure.rest_id
    LEFT JOIN (
        SELECT
            rd.dependency_id,
            rd.url,
            MIN(c1.author_date) AS first_commit_date,
            MAX(c1.author_date) AS last_commit_date,
            MIN(rd.first_use_data) AS first_use_date,
            MAX(rd.last_use_data) AS last_use_date
        FROM
            repos_to_dependencies rd
        LEFT JOIN
            commits c1 ON c1.repo_url = rd.url
        GROUP BY
            rd.dependency_id,
            rd.url
    ) subquery ON subquery.dependency_id = d.internal_id
    LEFT JOIN
        commits first_commit ON first_commit.author_date = subquery.first_commit_date
    LEFT JOIN
        commits last_commit ON last_commit.author_date = subquery.last_commit_date
    WHERE du.updated_at IS NULL OR du.updated_at < $1
)
SELECT
    login,
    user_id,
    dependency_id,
    MIN(first_use_date) AS earliest_first_use_date,
    MAX(last_use_date) AS latest_last_use_date
FROM
    computed_dates
GROUP BY
    login,
    user_id,
    dependency_id
`

type GetUserDependenciesByUpdatedAtRow struct {
	Login                sql.NullString `json:"login"`
	UserID               int32          `json:"user_id"`
	DependencyID         int32          `json:"dependency_id"`
	EarliestFirstUseDate interface{}    `json:"earliest_first_use_date"`
	LatestLastUseDate    interface{}    `json:"latest_last_use_date"`
}

func (q *Queries) GetUserDependenciesByUpdatedAt(ctx context.Context, updatedAt sql.NullInt64) ([]GetUserDependenciesByUpdatedAtRow, error) {
	rows, err := q.query(ctx, q.getUserDependenciesByUpdatedAtStmt, getUserDependenciesByUpdatedAt, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDependenciesByUpdatedAtRow
	for rows.Next() {
		var i GetUserDependenciesByUpdatedAtRow
		if err := rows.Scan(
			&i.Login,
			&i.UserID,
			&i.DependencyID,
			&i.EarliestFirstUseDate,
			&i.LatestLastUseDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initializeUserDependencies = `-- name: InitializeUserDependencies :exec
INSERT INTO user_to_dependencies ( user_id, dependency_id)
SELECT  internal_id, unnest($2::int[])
FROM github_users
WHERE login = $1
ON CONFLICT (user_id, dependency_id) DO NOTHING
`

type InitializeUserDependenciesParams struct {
	Login   string  `json:"login"`
	Column2 []int32 `json:"column_2"`
}

func (q *Queries) InitializeUserDependencies(ctx context.Context, arg InitializeUserDependenciesParams) error {
	_, err := q.exec(ctx, q.initializeUserDependenciesStmt, initializeUserDependencies, arg.Login, pq.Array(arg.Column2))
	return err
}
